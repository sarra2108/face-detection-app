/*! For license information please see 554.min.js.LICENSE.txt */
(this.webpackChunk_tsparticles_plugin_poisson_disc=this.webpackChunk_tsparticles_plugin_poisson_disc||[]).push([[554],{554:(i,t,s)=>{s.d(t,{PoissonInstance:()=>h});var e=s(303);const o=2*Math.PI;class n{constructor(i,t,s,e,o){this.size={...i},this.radius=t,this.retries=s,this.dimensions=e,this.cellSize=Math.floor(this.radius/Math.sqrt(this.dimensions)),this.cols=Math.floor(this.size.width/this.cellSize),this.rows=Math.floor(this.size.height/this.cellSize),this.points=[],this.active=[],this.grid=[],this.firstPoint=o?{...o}:void 0,this.reset()}addPoint(i){const t={position:{...i},gridPosition:{x:Math.floor(i.x/this.cellSize),y:Math.floor(i.y/this.cellSize)}},s=this.points.length;this.points.push(t),this.grid[t.gridPosition.y][t.gridPosition.x]=s,this.active.push(s)}getRandom(i,t){return Math.floor((0,e.getRandom)()*(t-i))+i}initialiseGrid(){for(let i=0;i<=this.rows;i++){this.grid[i]=[];for(let t=0;t<=this.cols;t++)this.grid[i][t]=-1}}reset(){if(this.points=[],this.active=[],this.grid=[],this.initialiseGrid(),this.firstPoint)this.addPoint(this.firstPoint);else{const i=0;this.addPoint({x:this.getRandom(i,this.size.width),y:this.getRandom(i,this.size.height)})}}async run(){this.reset();for(;this.active.length>0;)await this.steps(1)}async steps(i){for(let t=0;t<i;t++)this.active.length<=0||await this._step()}_getNewPoint(i,t){const s=t*(o/this.retries),n=this.getRandom(this.radius,2*this.radius),h=Math.cos(s)*n,a=Math.sin(s)*n,r={x:Math.floor(i.position.x+h),y:Math.floor(i.position.y+a)},c=Math.floor(r.x/this.cellSize),l=Math.floor(r.y/this.cellSize);if(r.x>0&&r.x<this.size.width&&r.y>0&&r.y<this.size.height&&this.grid[l][c]<0){for(let i=-1;i<=1;i++)for(let t=-1;t<=1;t++){const s={x:c+t,y:l+i};if(s.x>=0&&s.y>=0&&s.x<this.cols&&s.y<this.rows&&(s.x!==c||s.y!==l)&&this.grid[s.y][s.x]>=0){const i=this.grid[s.y][s.x],t=this.points[i];if((0,e.getDistance)(r,t.position)<this.radius)return}}return r}}async _step(){const i=this.getRandom(0,this.active.length);return new Promise((t=>{let s=!1;for(let t=0;t<this.retries;t++){const e=this._getNewPoint(this.points[this.active[i]],t);if(e){s=!0,this.addPoint(e);break}}if(!s){const t=1;this.active.splice(i,t)}t()}))}}class h{constructor(i,t){this._container=i,this._engine=t,this._currentIndex=0}async init(){await this._initData()}particlePosition(i){const t=this._container.actualOptions.poisson;if(this.poissonDisc&&t?.enable&&!(this._currentIndex>=this.poissonDisc.points.length))return i??this.poissonDisc?.points[this._currentIndex++]?.position}resize(){const i=this._container,t=i.actualOptions.poisson;if(!t?.enable)return;this.redrawTimeout&&clearTimeout(this.redrawTimeout);this.redrawTimeout=window.setTimeout((()=>{(async()=>{await this._initData(),await i.particles.redraw()})()}),250)}stop(){delete this.poissonDisc}async _initData(){const i=this._container,t=i.actualOptions.poisson,s=i.actualOptions.particles,o=i.canvas.size,h=i.retina.pixelRatio;if(!t?.enable)return;this._currentIndex=0,this.poissonDisc=new n(o,t.radius?t.radius*h:Math.max((0,e.getRangeMax)(s.size.value)*h,Math.sqrt(o.width*o.height/s.number.value)),t.retries,t.dimensions);t.steps>0?await this.poissonDisc.steps(t.steps):await this.poissonDisc.run()}}}}]);