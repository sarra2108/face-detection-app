/*!
 * Author : Matteo Bruni
 * MIT license: https://opensource.org/licenses/MIT
 * Demo / Generator : https://particles.js.org/
 * GitHub : https://www.github.com/matteobruni/tsparticles
 * How to use? : Check the GitHub README
 * v3.3.0
 */
"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(this["webpackChunk_tsparticles_all"] = this["webpackChunk_tsparticles_all"] || []).push([["plugins_polygonMask_dist_browser_PolygonMaskInstance_js"],{

/***/ "../../plugins/polygonMask/dist/browser/PolygonMaskInstance.js":
/*!*********************************************************************!*\
  !*** ../../plugins/polygonMask/dist/browser/PolygonMaskInstance.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PolygonMaskInstance: () => (/* binding */ PolygonMaskInstance)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"../../engine/dist/browser/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../../plugins/polygonMask/dist/browser/utils.js\");\n\n\nconst noPolygonDataLoaded = `${_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.errorPrefix} No polygon data loaded.`,\n  noPolygonFound = `${_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.errorPrefix} No polygon found, you need to specify SVG url in config.`,\n  origin = {\n    x: 0,\n    y: 0\n  },\n  half = 0.5,\n  double = 2;\nclass PolygonMaskInstance {\n  constructor(container, engine) {\n    this._checkInsidePolygon = position => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options?.enable || options.type === \"none\" || options.type === \"inline\") {\n        return true;\n      }\n      if (!this.raw) {\n        throw new Error(noPolygonFound);\n      }\n      const canvasSize = container.canvas.size,\n        x = position?.x ?? (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * canvasSize.width,\n        y = position?.y ?? (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * canvasSize.height,\n        indexOffset = 1;\n      let inside = false;\n      for (let i = 0, j = this.raw.length - indexOffset; i < this.raw.length; j = i++) {\n        const pi = this.raw[i],\n          pj = this.raw[j],\n          intersect = pi.y > y !== pj.y > y && x < (pj.x - pi.x) * (y - pi.y) / (pj.y - pi.y) + pi.x;\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n      if (options.type === \"inside\") {\n        return inside;\n      } else {\n        return options.type === \"outside\" ? !inside : false;\n      }\n    };\n    this._createPath2D = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options || !this.paths?.length) {\n        return;\n      }\n      for (const path of this.paths) {\n        const pathData = path.element?.getAttribute(\"d\");\n        if (pathData) {\n          const path2d = new Path2D(pathData),\n            matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix(),\n            finalPath = new Path2D(),\n            transform = matrix.scale(this._scale);\n          if (finalPath.addPath) {\n            finalPath.addPath(path2d, transform);\n            path.path2d = finalPath;\n          } else {\n            delete path.path2d;\n          }\n        } else {\n          delete path.path2d;\n        }\n        if (path.path2d ?? !this.raw) {\n          continue;\n        }\n        path.path2d = new Path2D();\n        const firstIndex = 0,\n          firstPoint = this.raw[firstIndex];\n        path.path2d.moveTo(firstPoint.x, firstPoint.y);\n        this.raw.forEach((pos, i) => {\n          if (i > firstIndex) {\n            path.path2d?.lineTo(pos.x, pos.y);\n          }\n        });\n        path.path2d.closePath();\n      }\n    };\n    this._downloadSvgPath = async (svgUrl, force) => {\n      const options = this._container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      const url = svgUrl ?? options.url,\n        forceDownload = force ?? false;\n      if (!url || this.paths !== undefined && !forceDownload) {\n        return this.raw;\n      }\n      const req = await fetch(url);\n      if (!req.ok) {\n        throw new Error(`${_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.errorPrefix} occurred during polygon mask download`);\n      }\n      return await this._parseSvgPath(await req.text(), force);\n    };\n    this._drawPoints = () => {\n      if (!this.raw) {\n        return;\n      }\n      for (const item of this.raw) {\n        void this._container.particles.addParticle({\n          x: item.x,\n          y: item.y\n        });\n      }\n    };\n    this._getEquidistantPointByIndex = index => {\n      const container = this._container,\n        options = container.actualOptions,\n        polygonMaskOptions = options.polygon;\n      if (!polygonMaskOptions) {\n        return;\n      }\n      if (!this.raw?.length || !this.paths?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      let offset = 0,\n        point;\n      const baseAccumulator = 0,\n        totalLength = this.paths.reduce((tot, path) => tot + path.length, baseAccumulator),\n        distance = totalLength / options.particles.number.value;\n      for (const path of this.paths) {\n        const pathDistance = distance * index - offset;\n        if (pathDistance <= path.length) {\n          point = path.element.getPointAtLength(pathDistance);\n          break;\n        } else {\n          offset += path.length;\n        }\n      }\n      const scale = this._scale;\n      return {\n        x: (point?.x ?? origin.x) * scale + (this.offset?.x ?? origin.x),\n        y: (point?.y ?? origin.y) * scale + (this.offset?.y ?? origin.y)\n      };\n    };\n    this._getPointByIndex = index => {\n      if (!this.raw?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const coords = this.raw[index % this.raw.length];\n      return {\n        x: coords.x,\n        y: coords.y\n      };\n    };\n    this._getRandomPoint = () => {\n      if (!this.raw?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const coords = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.itemFromArray)(this.raw);\n      return {\n        x: coords.x,\n        y: coords.y\n      };\n    };\n    this._getRandomPointByLength = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      if (!this.raw?.length || !this.paths?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const path = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.itemFromArray)(this.paths),\n        offset = 1,\n        distance = Math.floor((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * path.length) + offset,\n        point = path.element.getPointAtLength(distance),\n        scale = this._scale;\n      return {\n        x: point.x * scale + (this.offset?.x ?? origin.x),\n        y: point.y * scale + (this.offset?.y ?? origin.y)\n      };\n    };\n    this._initRawData = async force => {\n      const options = this._container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      if (options.url) {\n        this.raw = await this._downloadSvgPath(options.url, force);\n      } else if (options.data) {\n        const data = options.data;\n        let svg;\n        if ((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.isString)(data)) {\n          svg = data;\n        } else {\n          const getPath = p => `<path d=\"${p}\" />`,\n            path = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.isArray)(data.path) ? data.path.map(getPath).join(\"\") : getPath(data.path);\n          const namespaces = 'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n          svg = `<svg ${namespaces} width=\"${data.size.width}\" height=\"${data.size.height}\">${path}</svg>`;\n        }\n        this.raw = await this._parseSvgPath(svg, force);\n      }\n      this._createPath2D();\n      this._engine.dispatchEvent(\"polygonMaskLoaded\", {\n        container: this._container\n      });\n    };\n    this._parseSvgPath = async (xml, force) => {\n      const forceDownload = force ?? false;\n      if (this.paths !== undefined && !forceDownload) {\n        return this.raw;\n      }\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      const parser = new DOMParser(),\n        doc = parser.parseFromString(xml, \"image/svg+xml\"),\n        firstIndex = 0,\n        svg = doc.getElementsByTagName(\"svg\")[firstIndex];\n      let svgPaths = svg.getElementsByTagName(\"path\");\n      if (!svgPaths.length) {\n        svgPaths = doc.getElementsByTagName(\"path\");\n      }\n      this.paths = [];\n      for (let i = 0; i < svgPaths.length; i++) {\n        const path = svgPaths.item(i);\n        if (path) {\n          this.paths.push({\n            element: path,\n            length: path.getTotalLength()\n          });\n        }\n      }\n      const scale = this._scale;\n      this.dimension.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\") * scale;\n      this.dimension.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\") * scale;\n      const position = options.position ?? {\n          x: 50,\n          y: 50\n        },\n        canvasSize = container.canvas.size;\n      this.offset = {\n        x: canvasSize.width * position.x / _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.percentDenominator - this.dimension.width * half,\n        y: canvasSize.height * position.y / _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.percentDenominator - this.dimension.height * half\n      };\n      const {\n        parsePaths\n      } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./utils.js */ \"../../plugins/polygonMask/dist/browser/utils.js\"));\n      return parsePaths(this.paths, scale, this.offset);\n    };\n    this._polygonBounce = (particle, delta, direction) => {\n      const options = this._container.actualOptions.polygon;\n      if (!this.raw || !options?.enable || direction !== \"top\") {\n        return false;\n      }\n      if (options.type === \"inside\" || options.type === \"outside\") {\n        let closest, dx, dy;\n        const pos = particle.getPosition(),\n          radius = particle.getRadius(),\n          offset = 1;\n        for (let i = 0, j = this.raw.length - offset; i < this.raw.length; j = i++) {\n          const pi = this.raw[i],\n            pj = this.raw[j];\n          closest = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.calcClosestPointOnSegment)(pi, pj, pos);\n          const dist = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistances)(pos, closest);\n          [dx, dy] = [dist.dx, dist.dy];\n          if (dist.distance < radius) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.segmentBounce)(pi, pj, particle.velocity);\n            return true;\n          }\n        }\n        if (closest && dx !== undefined && dy !== undefined && !this._checkInsidePolygon(pos)) {\n          const factor = {\n              x: 1,\n              y: 1\n            },\n            diameter = radius * double,\n            inverse = -1;\n          if (pos.x >= closest.x) {\n            factor.x = -1;\n          }\n          if (pos.y >= closest.y) {\n            factor.y = -1;\n          }\n          particle.position.x = closest.x + diameter * factor.x;\n          particle.position.y = closest.y + diameter * factor.y;\n          particle.velocity.mult(inverse);\n          return true;\n        }\n      } else if (options.type === \"inline\" && particle.initialPosition) {\n        const dist = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistance)(particle.initialPosition, particle.getPosition()),\n          {\n            velocity\n          } = particle;\n        if (dist > this._moveRadius) {\n          velocity.x = velocity.y * half - velocity.x;\n          velocity.y = velocity.x * half - velocity.y;\n          return true;\n        }\n      }\n      return false;\n    };\n    this._randomPoint = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      let position;\n      if (options.type === \"inline\") {\n        switch (options.inline.arrangement) {\n          case \"random-point\":\n            position = this._getRandomPoint();\n            break;\n          case \"random-length\":\n            position = this._getRandomPointByLength();\n            break;\n          case \"equidistant\":\n            position = this._getEquidistantPointByIndex(container.particles.count);\n            break;\n          case \"one-per-point\":\n          case \"per-point\":\n          default:\n            position = this._getPointByIndex(container.particles.count);\n        }\n      } else {\n        const canvasSize = container.canvas.size;\n        position = {\n          x: (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * canvasSize.width,\n          y: (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * canvasSize.height\n        };\n      }\n      if (this._checkInsidePolygon(position)) {\n        return position;\n      } else {\n        return this._randomPoint();\n      }\n    };\n    this._container = container;\n    this._engine = engine;\n    this.dimension = {\n      height: 0,\n      width: 0\n    };\n    this._moveRadius = 0;\n    this._scale = 1;\n  }\n  clickPositionValid(position) {\n    const options = this._container.actualOptions.polygon;\n    return !!options?.enable && options.type !== \"none\" && options.type !== \"inline\" && this._checkInsidePolygon(position);\n  }\n  draw(context) {\n    if (!this.paths?.length) {\n      return;\n    }\n    const options = this._container.actualOptions.polygon;\n    if (!options?.enable) {\n      return;\n    }\n    const polygonDraw = options.draw;\n    if (!polygonDraw.enable) {\n      return;\n    }\n    const rawData = this.raw;\n    for (const path of this.paths) {\n      const path2d = path.path2d;\n      if (!context) {\n        continue;\n      }\n      if (path2d && this.offset) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.drawPolygonMaskPath)(context, path2d, polygonDraw.stroke, this.offset);\n      } else if (rawData) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.drawPolygonMask)(context, rawData, polygonDraw.stroke);\n      }\n    }\n  }\n  async init() {\n    const container = this._container,\n      polygonMaskOptions = container.actualOptions.polygon,\n      pxRatio = container.retina.pixelRatio;\n    if (!polygonMaskOptions) {\n      return;\n    }\n    this._moveRadius = polygonMaskOptions.move.radius * pxRatio;\n    this._scale = polygonMaskOptions.scale * pxRatio;\n    if (polygonMaskOptions.enable) {\n      await this._initRawData();\n    }\n  }\n  particleBounce(particle, delta, direction) {\n    return this._polygonBounce(particle, delta, direction);\n  }\n  particlePosition(position) {\n    const options = this._container.actualOptions.polygon,\n      defaultLength = 0;\n    if (!(options?.enable && (this.raw?.length ?? defaultLength) > defaultLength)) {\n      return;\n    }\n    return (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.deepExtend)({}, position ? position : this._randomPoint());\n  }\n  particlesInitialization() {\n    const options = this._container.actualOptions.polygon;\n    if (options?.enable && options.type === \"inline\" && (options.inline.arrangement === \"one-per-point\" || options.inline.arrangement === \"per-point\")) {\n      this._drawPoints();\n      return true;\n    }\n    return false;\n  }\n  resize() {\n    const container = this._container,\n      options = container.actualOptions.polygon;\n    if (!(options?.enable && options.type !== \"none\")) {\n      return;\n    }\n    if (this.redrawTimeout) {\n      clearTimeout(this.redrawTimeout);\n    }\n    const timeout = 250;\n    this.redrawTimeout = window.setTimeout(() => {\n      void (async () => {\n        await this._initRawData(true);\n        await container.particles.redraw();\n      })();\n    }, timeout);\n  }\n  stop() {\n    delete this.raw;\n    delete this.paths;\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/all/../../plugins/polygonMask/dist/browser/PolygonMaskInstance.js?");

/***/ }),

/***/ "../../plugins/polygonMask/dist/browser/utils.js":
/*!*******************************************************!*\
  !*** ../../plugins/polygonMask/dist/browser/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcClosestPointOnSegment: () => (/* binding */ calcClosestPointOnSegment),\n/* harmony export */   drawPolygonMask: () => (/* binding */ drawPolygonMask),\n/* harmony export */   drawPolygonMaskPath: () => (/* binding */ drawPolygonMaskPath),\n/* harmony export */   parsePaths: () => (/* binding */ parsePaths),\n/* harmony export */   segmentBounce: () => (/* binding */ segmentBounce)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"../../engine/dist/browser/index.js\");\n\nconst squareExp = 2,\n  inSegmentRange = {\n    min: 0,\n    max: 1\n  },\n  double = 2;\nfunction drawPolygonMask(context, rawData, stroke) {\n  const color = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.rangeColorToRgb)(stroke.color);\n  if (!color) {\n    return;\n  }\n  const firstIndex = 0,\n    firstItem = rawData[firstIndex];\n  context.beginPath();\n  context.moveTo(firstItem.x, firstItem.y);\n  for (const item of rawData) {\n    context.lineTo(item.x, item.y);\n  }\n  context.closePath();\n  context.strokeStyle = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getStyleFromRgb)(color);\n  context.lineWidth = stroke.width;\n  context.stroke();\n}\nfunction drawPolygonMaskPath(context, path, stroke, position) {\n  const defaultTransform = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1\n  };\n  context.setTransform(defaultTransform.a, defaultTransform.b, defaultTransform.c, defaultTransform.d, position.x, position.y);\n  const color = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.rangeColorToRgb)(stroke.color);\n  if (!color) {\n    return;\n  }\n  context.strokeStyle = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getStyleFromRgb)(color, stroke.opacity);\n  context.lineWidth = stroke.width;\n  context.stroke(path);\n  context.resetTransform();\n}\nfunction parsePaths(paths, scale, offset) {\n  const res = [],\n    defaultCount = 0;\n  for (const path of paths) {\n    const segments = path.element.pathSegList,\n      len = segments?.numberOfItems ?? defaultCount,\n      p = {\n        x: 0,\n        y: 0\n      };\n    for (let i = 0; i < len; i++) {\n      const segment = segments?.getItem(i),\n        svgPathSeg = window.SVGPathSeg;\n      switch (segment?.pathSegType) {\n        case svgPathSeg.PATHSEG_MOVETO_ABS:\n        case svgPathSeg.PATHSEG_LINETO_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n        case svgPathSeg.PATHSEG_ARC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n          {\n            const absSeg = segment;\n            p.x = absSeg.x;\n            p.y = absSeg.y;\n            break;\n          }\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n          p.x = segment.x;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n          p.y = segment.y;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_REL:\n        case svgPathSeg.PATHSEG_MOVETO_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n        case svgPathSeg.PATHSEG_ARC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n          {\n            const relSeg = segment;\n            p.x += relSeg.x;\n            p.y += relSeg.y;\n            break;\n          }\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n          p.x += segment.x;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n          p.y += segment.y;\n          break;\n        case svgPathSeg.PATHSEG_UNKNOWN:\n        case svgPathSeg.PATHSEG_CLOSEPATH:\n          continue;\n      }\n      res.push({\n        x: p.x * scale + offset.x,\n        y: p.y * scale + offset.y\n      });\n    }\n  }\n  return res;\n}\nfunction calcClosestPointOnSegment(s1, s2, pos) {\n  const {\n      dx: dx1,\n      dy: dy1\n    } = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistances)(pos, s1),\n    {\n      dx: dx2,\n      dy: dy2\n    } = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistances)(s2, s1),\n    t = (dx1 * dx2 + dy1 * dy2) / (dx2 ** squareExp + dy2 ** squareExp),\n    res = {\n      x: s1.x + dx2 * t,\n      y: s1.y + dy2 * t,\n      isOnSegment: t >= inSegmentRange.min && t <= inSegmentRange.max\n    };\n  if (t < inSegmentRange.min) {\n    res.x = s1.x;\n    res.y = s1.y;\n  } else if (t > inSegmentRange.max) {\n    res.x = s2.x;\n    res.y = s2.y;\n  }\n  return res;\n}\nfunction segmentBounce(start, stop, velocity) {\n  const {\n      dx,\n      dy\n    } = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistances)(start, stop),\n    wallAngle = Math.atan2(dy, dx),\n    wallNormal = _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)),\n    d = double * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n  wallNormal.multTo(d);\n  velocity.subFrom(wallNormal);\n}\n\n//# sourceURL=webpack://@tsparticles/all/../../plugins/polygonMask/dist/browser/utils.js?");

/***/ })

}]);