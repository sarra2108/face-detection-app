/*!
 * Author : Matteo Bruni
 * MIT license: https://opensource.org/licenses/MIT
 * Demo / Generator : https://particles.js.org/
 * GitHub : https://www.github.com/matteobruni/tsparticles
 * How to use? : Check the GitHub README
 * v3.3.0
 */
"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(this["webpackChunk_tsparticles_all"] = this["webpackChunk_tsparticles_all"] || []).push([["plugins_poisson_dist_browser_PoissonInstance_js"],{

/***/ "../../plugins/poisson/dist/browser/PoissonDisc.js":
/*!*********************************************************!*\
  !*** ../../plugins/poisson/dist/browser/PoissonDisc.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PoissonDisc: () => (/* binding */ PoissonDisc)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"../../engine/dist/browser/index.js\");\n\nconst double = 2,\n  doublePI = Math.PI * double;\nclass PoissonDisc {\n  constructor(size, radius, retries, dimensions, firstPoint) {\n    this.size = {\n      ...size\n    };\n    this.radius = radius;\n    this.retries = retries;\n    this.dimensions = dimensions;\n    this.cellSize = Math.floor(this.radius / Math.sqrt(this.dimensions));\n    this.cols = Math.floor(this.size.width / this.cellSize);\n    this.rows = Math.floor(this.size.height / this.cellSize);\n    this.points = [];\n    this.active = [];\n    this.grid = [];\n    this.firstPoint = firstPoint ? {\n      ...firstPoint\n    } : undefined;\n    this.reset();\n  }\n  addPoint(inputPoint) {\n    const point = {\n        position: {\n          ...inputPoint\n        },\n        gridPosition: {\n          x: Math.floor(inputPoint.x / this.cellSize),\n          y: Math.floor(inputPoint.y / this.cellSize)\n        }\n      },\n      pointIndex = this.points.length;\n    this.points.push(point);\n    this.grid[point.gridPosition.y][point.gridPosition.x] = pointIndex;\n    this.active.push(pointIndex);\n  }\n  getRandom(min, max) {\n    return Math.floor((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * (max - min)) + min;\n  }\n  initialiseGrid() {\n    for (let y = 0; y <= this.rows; y++) {\n      this.grid[y] = [];\n      for (let x = 0; x <= this.cols; x++) {\n        this.grid[y][x] = -1;\n      }\n    }\n  }\n  reset() {\n    this.points = [];\n    this.active = [];\n    this.grid = [];\n    this.initialiseGrid();\n    if (this.firstPoint) {\n      this.addPoint(this.firstPoint);\n    } else {\n      const minCoordinate = 0;\n      this.addPoint({\n        x: this.getRandom(minCoordinate, this.size.width),\n        y: this.getRandom(minCoordinate, this.size.height)\n      });\n    }\n  }\n  async run() {\n    this.reset();\n    const minCount = 0,\n      step = 1;\n    while (this.active.length > minCount) {\n      await this.steps(step);\n    }\n  }\n  async steps(steps) {\n    const minCount = 0;\n    for (let i = 0; i < steps; i++) {\n      if (this.active.length <= minCount) {\n        continue;\n      }\n      await this._step();\n    }\n  }\n  _getNewPoint(currentPoint, tries) {\n    const minCoordinate = 0,\n      gridMinValue = 0,\n      maxNeighbourIndex = 1,\n      newAngle = tries * (doublePI / this.retries),\n      newDist = this.getRandom(this.radius, this.radius * double),\n      offset = {\n        x: Math.cos(newAngle) * newDist,\n        y: Math.sin(newAngle) * newDist\n      },\n      newPoint = {\n        x: Math.floor(currentPoint.position.x + offset.x),\n        y: Math.floor(currentPoint.position.y + offset.y)\n      },\n      newGridCoords = {\n        x: Math.floor(newPoint.x / this.cellSize),\n        y: Math.floor(newPoint.y / this.cellSize)\n      };\n    if (newPoint.x > minCoordinate && newPoint.x < this.size.width && newPoint.y > minCoordinate && newPoint.y < this.size.height) {\n      if (this.grid[newGridCoords.y][newGridCoords.x] < gridMinValue) {\n        for (let i = -1; i <= maxNeighbourIndex; i++) {\n          for (let j = -1; j <= maxNeighbourIndex; j++) {\n            const neighbourGrid = {\n              x: newGridCoords.x + j,\n              y: newGridCoords.y + i\n            };\n            if (neighbourGrid.x >= minCoordinate && neighbourGrid.y >= minCoordinate && neighbourGrid.x < this.cols && neighbourGrid.y < this.rows && (neighbourGrid.x !== newGridCoords.x || neighbourGrid.y !== newGridCoords.y)) {\n              if (this.grid[neighbourGrid.y][neighbourGrid.x] >= gridMinValue) {\n                const neighbourIndex = this.grid[neighbourGrid.y][neighbourGrid.x],\n                  neighbour = this.points[neighbourIndex],\n                  dist = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistance)(newPoint, neighbour.position);\n                if (dist < this.radius) {\n                  return;\n                }\n              }\n            }\n          }\n        }\n      } else {\n        return;\n      }\n    } else {\n      return;\n    }\n    return newPoint;\n  }\n  async _step() {\n    const minCount = 0,\n      randomActive = this.getRandom(minCount, this.active.length);\n    return new Promise(resolve => {\n      let foundNewPoint = false;\n      for (let tries = 0; tries < this.retries; tries++) {\n        const newPoint = this._getNewPoint(this.points[this.active[randomActive]], tries);\n        if (newPoint) {\n          foundNewPoint = true;\n          this.addPoint(newPoint);\n          break;\n        }\n      }\n      if (!foundNewPoint) {\n        const deleteCount = 1;\n        this.active.splice(randomActive, deleteCount);\n      }\n      resolve();\n    });\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/all/../../plugins/poisson/dist/browser/PoissonDisc.js?");

/***/ }),

/***/ "../../plugins/poisson/dist/browser/PoissonInstance.js":
/*!*************************************************************!*\
  !*** ../../plugins/poisson/dist/browser/PoissonInstance.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PoissonInstance: () => (/* binding */ PoissonInstance)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"../../engine/dist/browser/index.js\");\n/* harmony import */ var _PoissonDisc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PoissonDisc.js */ \"../../plugins/poisson/dist/browser/PoissonDisc.js\");\n\n\nclass PoissonInstance {\n  constructor(container, engine) {\n    this._container = container;\n    this._engine = engine;\n    this._currentIndex = 0;\n  }\n  async init() {\n    await this._initData();\n  }\n  particlePosition(position) {\n    const container = this._container,\n      options = container.actualOptions.poisson;\n    if (!this.poissonDisc || !(options?.enable ?? false) || this._currentIndex >= this.poissonDisc.points.length) {\n      return;\n    }\n    return position ?? this.poissonDisc?.points[this._currentIndex++]?.position;\n  }\n  resize() {\n    const container = this._container,\n      options = container.actualOptions.poisson;\n    if (!(options?.enable ?? false)) {\n      return;\n    }\n    if (this.redrawTimeout) {\n      clearTimeout(this.redrawTimeout);\n    }\n    const timeout = 250;\n    this.redrawTimeout = window.setTimeout(() => {\n      void (async () => {\n        await this._initData();\n        await container.particles.redraw();\n      })();\n    }, timeout);\n  }\n  stop() {\n    delete this.poissonDisc;\n  }\n  async _initData() {\n    const container = this._container,\n      poissonOptions = container.actualOptions.poisson,\n      particlesOptions = container.actualOptions.particles,\n      canvasSize = container.canvas.size,\n      pixelRatio = container.retina.pixelRatio;\n    if (!poissonOptions?.enable) {\n      return;\n    }\n    this._currentIndex = 0;\n    this.poissonDisc = new _PoissonDisc_js__WEBPACK_IMPORTED_MODULE_1__.PoissonDisc(canvasSize, poissonOptions.radius ? poissonOptions.radius * pixelRatio : Math.max((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRangeMax)(particlesOptions.size.value) * pixelRatio, Math.sqrt(canvasSize.width * canvasSize.height / particlesOptions.number.value)), poissonOptions.retries, poissonOptions.dimensions);\n    const noSteps = 0;\n    if (poissonOptions.steps > noSteps) {\n      await this.poissonDisc.steps(poissonOptions.steps);\n    } else {\n      await this.poissonDisc.run();\n    }\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/all/../../plugins/poisson/dist/browser/PoissonInstance.js?");

/***/ })

}]);