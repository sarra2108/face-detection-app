/*!
 * Author : Matteo Bruni
 * MIT license: https://opensource.org/licenses/MIT
 * Demo / Generator : https://particles.js.org/
 * GitHub : https://www.github.com/matteobruni/tsparticles
 * How to use? : Check the GitHub README
 * v3.3.0
 */
"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(this["webpackChunk_tsparticles_plugin_sounds"] = this["webpackChunk_tsparticles_plugin_sounds"] || []).push([["dist_browser_SoundsInstance_js"],{

/***/ "./dist/browser/SoundsInstance.js":
/*!****************************************!*\
  !*** ./dist/browser/SoundsInstance.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SoundsInstance: () => (/* binding */ SoundsInstance)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"@tsparticles/engine\");\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./dist/browser/utils.js\");\n\n\nconst zIndexOffset = 1,\n  rightOffset = 1,\n  minVolume = 0;\nfunction initImage(data) {\n  const img = document.createElement(\"img\"),\n    {\n      clickCb,\n      container,\n      display,\n      iconOptions,\n      margin,\n      options,\n      pos,\n      rightOffsets\n    } = data,\n    {\n      width,\n      path,\n      style,\n      svg\n    } = iconOptions,\n    defaultAccumulator = 0;\n  setIconStyle(img, pos.top + margin, pos.right - (margin * (rightOffsets.length + rightOffset) + width + rightOffsets.reduce((a, b) => a + b, defaultAccumulator)), display, options.fullScreen.zIndex + zIndexOffset, width, margin, style);\n  img.src = path ?? (svg ? `data:image/svg+xml;base64,${btoa(svg)}` : \"\");\n  const parent = container.canvas.element?.parentNode ?? document.body;\n  parent.append(img);\n  img.addEventListener(\"click\", () => {\n    void clickCb();\n  });\n  return img;\n}\nfunction removeImage(image) {\n  if (!image) {\n    return;\n  }\n  image.remove();\n}\nfunction setIconStyle(icon, top, left, display, zIndex, width, margin, style) {\n  icon.style.userSelect = \"none\";\n  icon.style.webkitUserSelect = \"none\";\n  icon.style.position = \"absolute\";\n  icon.style.top = `${top + margin}px`;\n  icon.style.left = `${left - margin - width}px`;\n  icon.style.display = display;\n  icon.style.zIndex = `${zIndex + zIndexOffset}`;\n  icon.style.cssText += style;\n}\nclass SoundsInstance {\n  constructor(container, engine) {\n    this._addBuffer = audioCtx => {\n      const buffer = audioCtx.createBufferSource();\n      this._audioSources.push(buffer);\n      return buffer;\n    };\n    this._addOscillator = audioCtx => {\n      const oscillator = audioCtx.createOscillator();\n      this._audioSources.push(oscillator);\n      return oscillator;\n    };\n    this._initEvents = () => {\n      const container = this._container,\n        soundsOptions = container.actualOptions.sounds;\n      if (!soundsOptions?.enable || !container.canvas.element) {\n        return;\n      }\n      for (const event of soundsOptions.events) {\n        const cb = args => {\n          void (async () => {\n            const filterNotValid = event.filter && !event.filter(args);\n            if (this._container !== args.container) {\n              return;\n            }\n            if (!this._container || !!this._container.muted || this._container.destroyed) {\n              (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.executeOnSingleOrMultiple)(event.event, item => {\n                this._engine.removeEventListener(item, cb);\n              });\n              return;\n            }\n            if (filterNotValid) {\n              return;\n            }\n            const defaultNoteIndex = 0;\n            if (event.audio) {\n              this._playBuffer((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.itemFromSingleOrMultiple)(event.audio));\n            } else if (event.melodies) {\n              const melody = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.itemFromArray)(event.melodies);\n              if (melody.melodies.length) {\n                await Promise.allSettled(melody.melodies.map(m => this._playNote(m.notes, defaultNoteIndex, melody.loop)));\n              } else {\n                await this._playNote(melody.notes, defaultNoteIndex, melody.loop);\n              }\n            } else if (event.notes) {\n              const note = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.itemFromArray)(event.notes);\n              await this._playNote([note], defaultNoteIndex, false);\n            }\n          })();\n        };\n        (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.executeOnSingleOrMultiple)(event.event, item => {\n          this._engine.addEventListener(item, cb);\n        });\n      }\n    };\n    this._mute = async () => {\n      const container = this._container,\n        audioContext = this._getAudioContext();\n      for (const source of this._audioSources) {\n        this._removeAudioSource(source);\n      }\n      if (this._gain) {\n        this._gain.disconnect();\n      }\n      await audioContext.close();\n      container.audioContext = undefined;\n      this._engine.dispatchEvent(\"soundsMuted\", {\n        container: this._container\n      });\n    };\n    this._playBuffer = audio => {\n      const audioBuffer = this._audioMap.get(audio.source);\n      if (!audioBuffer) {\n        return;\n      }\n      const audioCtx = this._container.audioContext;\n      if (!audioCtx) {\n        return;\n      }\n      const source = this._addBuffer(audioCtx);\n      source.loop = audio.loop;\n      source.buffer = audioBuffer;\n      source.connect(this._gain ?? audioCtx.destination);\n      source.start();\n    };\n    this._playFrequency = async (frequency, duration) => {\n      if (!this._gain || this._container.muted) {\n        return;\n      }\n      const audioContext = this._getAudioContext(),\n        oscillator = this._addOscillator(audioContext);\n      oscillator.connect(this._gain);\n      oscillator.type = \"sine\";\n      oscillator.frequency.value = frequency;\n      oscillator.start();\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this._removeAudioSource(oscillator);\n          resolve();\n        }, duration);\n      });\n    };\n    this._playMuteSound = () => {\n      if (this._container.muted) {\n        return;\n      }\n      const audioContext = this._getAudioContext(),\n        gain = audioContext.createGain();\n      gain.connect(audioContext.destination);\n      gain.gain.value = 0;\n      const oscillator = audioContext.createOscillator();\n      oscillator.connect(gain);\n      oscillator.type = \"sine\";\n      oscillator.frequency.value = 1;\n      oscillator.start();\n      setTimeout(() => {\n        oscillator.stop();\n        oscillator.disconnect();\n        gain.disconnect();\n      });\n    };\n    this._playNote = async (notes, noteIdx, loop) => {\n      if (this._container.muted) {\n        return;\n      }\n      const note = notes[noteIdx];\n      if (!note) {\n        return;\n      }\n      const value = note.value;\n      const promises = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.executeOnSingleOrMultiple)(value, async (_, idx) => {\n        return this._playNoteValue(notes, noteIdx, idx);\n      });\n      await ((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.isArray)(promises) ? Promise.allSettled(promises) : promises);\n      const indexOffset = 1;\n      let nextNoteIdx = noteIdx + indexOffset;\n      if (loop && nextNoteIdx >= notes.length) {\n        nextNoteIdx = nextNoteIdx % notes.length;\n      }\n      if (this._container.muted) {\n        return;\n      }\n      await this._playNote(notes, nextNoteIdx, loop);\n    };\n    this._playNoteValue = async (notes, noteIdx, valueIdx) => {\n      const note = notes[noteIdx];\n      if (!note) {\n        return;\n      }\n      const value = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.itemFromSingleOrMultiple)(note.value, valueIdx, true);\n      try {\n        const freq = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getNoteFrequency)(value);\n        if (!(0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.isNumber)(freq)) {\n          return;\n        }\n        await this._playFrequency(freq, note.duration);\n      } catch (e) {\n        (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getLogger)().error(e);\n      }\n    };\n    this._removeAudioSource = source => {\n      source.stop();\n      source.disconnect();\n      const deleteCount = 1;\n      this._audioSources.splice(this._audioSources.indexOf(source), deleteCount);\n    };\n    this._unmute = () => {\n      const container = this._container,\n        options = container.actualOptions,\n        soundsOptions = options.sounds;\n      if (!soundsOptions) {\n        return;\n      }\n      const audioContext = this._getAudioContext();\n      if (!this._audioSources) {\n        this._audioSources = [];\n      }\n      const gain = audioContext.createGain();\n      gain.connect(audioContext.destination);\n      gain.gain.value = soundsOptions.volume.value / _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.percentDenominator;\n      this._gain = gain;\n      this._initEvents();\n      this._engine.dispatchEvent(\"soundsUnmuted\", {\n        container: this._container\n      });\n    };\n    this._updateMuteIcons = () => {\n      const container = this._container,\n        soundsOptions = container.actualOptions.sounds;\n      if (!soundsOptions?.enable || !soundsOptions.icons.enable) {\n        return;\n      }\n      const muteImg = this._muteImg,\n        unmuteImg = this._unmuteImg;\n      if (muteImg) {\n        muteImg.style.display = container.muted ? \"block\" : \"none\";\n      }\n      if (unmuteImg) {\n        unmuteImg.style.display = container.muted ? \"none\" : \"block\";\n      }\n    };\n    this._updateMuteStatus = async () => {\n      const container = this._container,\n        audioContext = this._getAudioContext();\n      if (container.muted) {\n        await audioContext?.suspend();\n        await this._mute();\n      } else {\n        await audioContext?.resume();\n        this._unmute();\n        this._playMuteSound();\n      }\n    };\n    this._updateVolume = async () => {\n      const container = this._container,\n        soundsOptions = container.actualOptions.sounds;\n      if (!soundsOptions?.enable) {\n        return;\n      }\n      (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.clamp)(this._volume, soundsOptions.volume.min, soundsOptions.volume.max);\n      let stateChanged = false;\n      if (this._volume <= minVolume && !container.muted) {\n        this._volume = 0;\n        container.muted = true;\n        stateChanged = true;\n      } else if (this._volume > minVolume && container.muted) {\n        container.muted = false;\n        stateChanged = true;\n      }\n      if (stateChanged) {\n        this._updateMuteIcons();\n        await this._updateMuteStatus();\n      }\n      if (this._gain?.gain) {\n        this._gain.gain.value = this._volume / _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.percentDenominator;\n      }\n    };\n    this._container = container;\n    this._engine = engine;\n    this._volume = 0;\n    this._audioSources = [];\n    this._audioMap = new Map();\n  }\n  async init() {\n    const container = this._container,\n      options = container.actualOptions,\n      soundsOptions = options.sounds;\n    if (!soundsOptions?.enable) {\n      return;\n    }\n    if (soundsOptions.autoPlay && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isWindowMuted)()) {\n      const firstClickHandler = () => {\n        removeEventListener(_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.mouseDownEvent, firstClickHandler);\n        removeEventListener(_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.touchStartEvent, firstClickHandler);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.unmuteWindow)();\n        void this.unmute();\n      };\n      const listenerOptions = {\n        capture: true,\n        once: true\n      };\n      addEventListener(_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.mouseDownEvent, firstClickHandler, listenerOptions);\n      addEventListener(_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.touchStartEvent, firstClickHandler, listenerOptions);\n    }\n    this._volume = soundsOptions.volume.value;\n    const events = soundsOptions.events;\n    this._audioMap = new Map();\n    for (const event of events) {\n      if (!event.audio) {\n        continue;\n      }\n      const promises = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.executeOnSingleOrMultiple)(event.audio, async audio => {\n        const response = await fetch(audio.source);\n        if (!response.ok) {\n          return;\n        }\n        const arrayBuffer = await response.arrayBuffer(),\n          audioContext = this._getAudioContext(),\n          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        this._audioMap.set(audio.source, audioBuffer);\n      });\n      if (promises instanceof Promise) {\n        await promises;\n      } else {\n        await Promise.allSettled(promises);\n      }\n    }\n  }\n  async mute() {\n    if (!this._container.muted) {\n      await this.toggleMute();\n    }\n  }\n  async start() {\n    const container = this._container,\n      options = container.actualOptions,\n      soundsOptions = options.sounds;\n    if (!soundsOptions?.enable || !container.canvas.element) {\n      return;\n    }\n    container.muted = true;\n    const canvas = container.canvas.element,\n      pos = {\n        top: canvas.offsetTop,\n        right: canvas.offsetLeft + canvas.offsetWidth\n      },\n      {\n        mute,\n        unmute,\n        volumeDown,\n        volumeUp\n      } = soundsOptions.icons,\n      margin = 10,\n      toggleMute = async () => {\n        await this.toggleMute();\n      },\n      enableIcons = soundsOptions.icons.enable,\n      display = enableIcons ? \"block\" : \"none\";\n    this._muteImg = initImage({\n      container,\n      options,\n      pos,\n      display,\n      iconOptions: mute,\n      margin,\n      rightOffsets: [volumeDown.width, volumeUp.width],\n      clickCb: toggleMute\n    });\n    this._unmuteImg = initImage({\n      container,\n      options,\n      pos,\n      display: \"none\",\n      iconOptions: unmute,\n      margin,\n      rightOffsets: [volumeDown.width, volumeUp.width],\n      clickCb: toggleMute\n    });\n    this._volumeDownImg = initImage({\n      container,\n      options,\n      pos,\n      display,\n      iconOptions: volumeDown,\n      margin,\n      rightOffsets: [volumeUp.width],\n      clickCb: async () => {\n        await this.volumeDown();\n      }\n    });\n    this._volumeUpImg = initImage({\n      container,\n      options,\n      pos,\n      display,\n      iconOptions: volumeUp,\n      margin,\n      rightOffsets: [],\n      clickCb: async () => {\n        await this.volumeUp();\n      }\n    });\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isWindowMuted)() && soundsOptions.autoPlay) {\n      await this.unmute();\n    }\n  }\n  stop() {\n    this._container.muted = true;\n    void (async () => {\n      await this._mute();\n      removeImage(this._muteImg);\n      removeImage(this._unmuteImg);\n      removeImage(this._volumeDownImg);\n      removeImage(this._volumeUpImg);\n    })();\n  }\n  async toggleMute() {\n    const container = this._container;\n    container.muted = !container.muted;\n    this._updateMuteIcons();\n    await this._updateMuteStatus();\n  }\n  async unmute() {\n    if (this._container.muted) {\n      await this.toggleMute();\n    }\n  }\n  async volumeDown() {\n    const container = this._container,\n      soundsOptions = container.actualOptions.sounds;\n    if (!soundsOptions?.enable) {\n      return;\n    }\n    if (container.muted) {\n      this._volume = 0;\n    }\n    this._volume -= soundsOptions.volume.step;\n    await this._updateVolume();\n  }\n  async volumeUp() {\n    const container = this._container,\n      soundsOptions = container.actualOptions.sounds;\n    if (!soundsOptions?.enable) {\n      return;\n    }\n    this._volume += soundsOptions.volume.step;\n    await this._updateVolume();\n  }\n  _getAudioContext() {\n    const container = this._container;\n    if (!container.audioContext) {\n      container.audioContext = new AudioContext();\n    }\n    return container.audioContext;\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/plugin-sounds/./dist/browser/SoundsInstance.js?");

/***/ })

}]);